/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/ 		var prefetchChunks = data[3] || [];
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/ 		// chunk prefetching for javascript
/******/ 		prefetchChunks.forEach(function(chunkId) {
/******/ 			if(installedChunks[chunkId] === undefined) {
/******/ 				installedChunks[chunkId] = null;
/******/ 				var link = document.createElement('link');
/******/
/******/ 				if (__webpack_require__.nc) {
/******/ 					link.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				link.rel = "prefetch";
/******/ 				link.as = "script";
/******/ 				link.href = jsonpScriptSrc(chunkId);
/******/ 				document.head.appendChild(link);
/******/ 			}
/******/ 		});
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"index": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"./dictionaryChinese":"./dictionaryChinese","./dictionaryEnglish":"./dictionaryEnglish"}[chunkId]||chunkId) + ".bundle.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	var startupResult = (function() {
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ 	})();
/******/
/******/ 	webpackJsonpCallback([[], {}, 0, ["./dictionaryChinese","./dictionaryEnglish"]]);
/******/ 	return startupResult;
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./src/actor.js":
/*!**********************!*\
  !*** ./src/actor.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Actor; });\n// inspired by AP Commputer Science's GridWorld\n// read up on interface mixins implements, class Location, class Grid\nclass Actor {\n    constructor(x,y) {\n        this.x = x\n        this.y = y\n    }\n\n    animate(){\n        // 1. determine what image we want to animate.\n        // 2. i feel like there should be a (move 1 step in time) method or should it just be animate\n    }\n    \n    get location(){\n        return {\n            x: this.x,\n            y: this.y\n        }\n    }\n\n}\n\n\n\n//# sourceURL=webpack:///./src/actor.js?");

/***/ }),

/***/ "./src/crono.js":
/*!**********************!*\
  !*** ./src/crono.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ \"./src/actor.js\");\n\n\nclass Crono extends _actor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\n    constructor(x, y, canvas, ctx, cronoleftimg, cronorightimg, cronoupimg, cronodownimg, cronothrust, keys, enemies) {\n        super(x,y)\n        this.canvas = canvas\n        this.ctx = ctx\n        this.alive = true ;\n        this.animate = this.animate\n        this.animateDeath = this.animateDeath.bind(this)\n        this.cronoleftimg = cronoleftimg\n        this.cronorightimg= cronorightimg\n        this.cronoupimg = cronoupimg\n        this.cronodownimg = cronodownimg\n        this.lastaction = this.cronodownimg\n        this.cronothrust = cronothrust\n        this.keys = keys\n        this.enemies = enemies\n        this.hp = 100\n\n\n        this.sprites = document.getElementById('sprites') \n        this.takingDamage = false\n        this.animateGrimace = false\n    }\n\n    poll() {\n    }\n    \n    // checkcollision is called every animate() in GAME CLASS\n    checkCollision() { // can use leetcodes overlapping rectangles to detect. want to add a get method for this.x,this.y and this.x + canvaswidthtakenupbycrono, etc.\n        for (const enemy of this.enemies) {\n            if (enemy.alive === false) continue\n\n            if ( ( (enemy.x - this.x)**2 + (enemy.y - this.y)**2 )**.5  < 20) {\n                this.takeDamage()\n            //  console.log('collision with enemy detected')\n\n            }\n        }\n    }\n\n    takeDamage() {\n        if (this.takingDamage === false) {\n            this.hp-- \n            this.takingDamage = true\n            this.animateGrimace = true\n            setTimeout( () => {\n                this.takingDamage = false\n            }, 5000)\n        } else if (this.takingDamage =  true && this.animateGrimace===true) {\n            this.ctx.drawImage(this.sprites, 80, 80, 30, 30, this.x, this.y, 50, 50)            \n            setTimeout(()=>this.animateGrimace = false,500)\n        }\n   \n\n    }\n\n    animateAttack(x, y, attackPicture) {\n        let leftsY\n        let leftsX\n        // x bigger the more right, y bigger the lower, arclength, 1\n        // this.y is where crono is y is where enemy is at the start\n        this.circleCenterY = (this.y + y )/ 2\n        this.circleCenterX = (this.x + x )/ 2\n        this.diameter = Math.pow(Math.pow((this.x-x),2) + Math.pow((this.y-y),2), 0.5)\n        // which unit is on the LEFT?\n        if (this.x < x){\n            leftsY = this.y\n            leftsX = this.x\n        } else {\n            leftsY = y\n            leftsX = x\n        }\n        this.angleStartClockwise = -Math.atan( (leftsY - this.circleCenterY) / (this.circleCenterX - leftsX)) + Math.PI\n        this.angleEndClockwise = Math.PI + this.angleStartClockwise\n\n        this.x = x\n        this.y = y\n        \n        this.ctx.drawImage(attackPicture, 0, 0, 500, 500, this.x, this.y + 50, 500, 500)\n        \n        this.lastaction = attackPicture\n    }\n    \n    // animate unfortuantely controls movement so i wnet with if(!this.animateGrimace)\n    animate() {\n       \n        let up = this.keys[38]\n        let down = this.keys[40]\n        let left = this.keys[37]\n        let right = this.keys[39]\n\n        if (right){\n            if (this.x < this.canvas.width - 30 && (!down && !up)) {\n                this.x += 4\n                if(!this.animateGrimace) this.ctx.drawImage(this.cronorightimg, 0, 0, 500, 500, this.x, this.y, 500, 500)\n            } else if (this.x > 0 - 30 && (down || up)) {\n                this.x += 2.8\n            }\n            this.lastaction = this.cronorightimg\n        } \n\n        if (left) {\n            if (this.x > 0 - 30 && (!down && !up)) {\n                this.x -= 4\n                if (!this.animateGrimace)this.ctx.drawImage(this.cronoleftimg, 0, 0, 500, 500, this.x, this.y, 500, 500)\n            } else if (this.x > 0 - 30 && (down || up)) {\n                this.x -= 2.8\n            }\n            this.lastaction = this.cronoleftimg\n        }\n\n        // down and up will overpower left and right as a lastaction\n        if (down) {\n            if (this.y < this.canvas.height - 30 && (!left && !right)) {\n                this.y += 4\n            } else if (this.y < this.canvas.height - 30 && (left || right)) {\n                this.y += 2.8\n            }\n            if (!this.animateGrimace)this.ctx.drawImage(this.cronodownimg, 0, 0, 500, 500, this.x, this.y, 500, 500)\n            this.lastaction = this.cronodownimg\n        }\n\n        if (up && !down) {\n            if (this.y > 0 - 30 && (!left && !right)) {\n                this.y -= 4\n            } else if (this.y > 0 - 30 && (left || right)) {\n                this.y -= 2.8\n            }\n            if (!this.animateGrimace)this.ctx.drawImage(this.cronoupimg, 0, 0, 500, 500, this.x, this.y, 500, 500)\n            this.lastaction = this.cronoupimg\n        } \n\n        if ( !left && !up && !right && !right && !down && !this.takingDamage ) {\n            if (!this.animateGrimace) this.ctx.drawImage(this.lastaction, 0, 0, 500, 500, this.x, this.y, 500, 500)\n        }\n\n        // if (this.takingDamage) {\n        //     this.ctx.drawImage(this.lastaction, 0, 0, 500, 500, this.x, this.y, 500, 500)\n        // }\n    }\n    \n    animateDeath() {\n        // if I have time\n    }\n\n\n\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Crono);\n\n\n//# sourceURL=webpack:///./src/crono.js?");

/***/ }),

/***/ "./src/enemy.js":
/*!**********************!*\
  !*** ./src/enemy.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ \"./src/actor.js\");\n\n// bundle splitting = split your bundle up but still dl both for first time users\n// code splitting = dont dl and load code you dont use\n\n\n// import { chineseDictionary as dictionary2 } from './chineseexpansionpack'\n\nclass Enemy extends _actor__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(x, y, canvas, ctx, imp, difficulty, bluepaint, gameMode, squarereticle, dictionary) {\n        super(x,y);\n        this.canvas = canvas;\n        this.ctx = ctx;\n        this.alive = true;\n        this.animate = this.animate.bind(this);\n        this.animateDeath = this.animateDeath.bind(this);\n        this.imp = imp;\n        this.difficulty = difficulty;\n        this.standStill = false;\n        this.bluepaint = bluepaint;\n        this.gameMode = gameMode;\n        this.squarereticle = squarereticle;\n        this.dictionary = dictionary\n\n      \n\n        this.word = this.dictionary[Math.floor(Math.random() * this.dictionary.length)];\n        \n        if(document.querySelector(`#soundToggle`).checked)\n        new Audio(`http://localhost:3001/word/${this.word}`).play()\n        \n\n    }\n\n    static CreateEnemy() {\n        // if I have time \n    }\n\n    animateReticle(){\n        this.ctx.drawImage(this.squarereticle, 0, 0, 400, 400, this.x-5, this.y-5, 55, 55)\n\n    }\n\n    animate(cronoX,cronoY){\n        // will this monster move\n        if (this.alive === true && this.standStill === false){\n            let randomMove = Math.random()\n            if(cronoX > this.x){\n                if (randomMove < .70){\n                    this.x += 1\n                } else if(randomMove >= .70 && randomMove < .99){\n                    this.x -= 1\n                } else{\n                    this.standStill = true\n                    setTimeout(() => this.standStill = false , 3000)\n                }\n            } else if(cronoX < this.x) {\n                if (randomMove < .70) {\n                    this.x -= 1\n                } else if (randomMove >= .70 && randomMove < .99) {\n                    this.x += 1\n                } else{\n                    this.standStill = true\n                    setTimeout(() => this.standStill = false, 3000)\n                } \n            }\n            if (cronoY > this.y) {\n                if (randomMove < .70) {\n                    this.y += 1\n                } else if (randomMove >= .70 && randomMove < .99) {\n                    this.y -= 1\n                } else{\n                    this.standStill = true\n                    setTimeout(() => this.standStill = false, 3000)\n                }\n            } else if (cronoY < this.y) {\n                if (randomMove < .70) {\n                    this.y -= 1\n                } else if (randomMove >= .70 && randomMove < .99) {\n                    this.y += 1\n                } else{\n                    this.standStill = true\n                    setTimeout(() => this.standStill = false, 3000)\n                }\n            } \n        }\n        // if alive draw the word above it and the monster itself\n        if (this.alive === true){\n            this.ctx.drawImage(this.imp, 0, 0, 200, 300, this.x, this.y, 500, 500)\n            this.ctx.fillStyle = \"white\";\n            this.ctx.font = `bold 50px ChronoType`;\n            this.ctx.fillText(this.word, this.x, this.y, 500, 500)\n        } \n        // if dead draw a blue splat instead\n        else if (this.alive === false){\n            this.ctx.drawImage(this.bluepaint, 0, 0, 500, 500, this.x, this.y, 60, 60)\n        }\n\n    }\n\n    animateDeath(){\n        // if I have time I can animate the death\n    }\n\n    wander() {\n        //if I have time I can do collision detection\n    }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Enemy);\n\n\n//# sourceURL=webpack:///./src/enemy.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enemy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enemy */ \"./src/enemy.js\");\n/* harmony import */ var _crono__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crono */ \"./src/crono.js\");\n/* harmony import */ var _trie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trie */ \"./src/trie.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui */ \"./src/ui.js\");\n\n\n\n\n\n\n// TBD 1. Add a monster Try data strcuture to highlight in red possible targets as a sort of demo of tries and like a targeting system to warn a user he\n// messed up in typing a monsters word DONE\n// 2. add chinese input into they key-area HALFDONE\n// 3. add splat sounds for kicks TBD\n// 4. finish collision detection and taking damage NOW glitchy\n// 5. implement a high score table with a notepad file or firebase or something with express MIDWAY\n// 6.animate the splash screen with words flying in / also maybe fade to black in the 0-2000 ms transition\n// 7. add in upload your own words\n// 8. draw the tracers for the reticle\n// 9. add symbols to make hp immutable (almost) w const HP = Symbol()\n// this[HP] = 100; Reflect.ownKeys() or Object.getOwnPropertySymbols() can detect\n// 10. https://developers.redhat.com/blog/2017/01/17/data-encapsulation-vs-immutability-in-javascript/ make a factory for enemys? for like a boss rather than inheritanc\n//BUGS TBD: \n// 1.  time needs to stop (timeElapsed ) when game is paused so wpm doesnt go to 0 and the next one enemy doesnt instaspawn after pause FIXED\n// 2. need to fix settimeouts on collision/damage taking and animating it TBD\n\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\"); // CAN this be done HERE?\n/* \nASAP: finish highscores inside gameover, finish up chinsee input and value changing \n*/\n\nclass Game {\n    constructor() {\n        this._getResources();\n        this._ensureDefaultSettings();\n        this._addListeners();\n        this.animateSplash(); \n\n\n\n      \n\n        //animate stops recursively calling itself then 0-2 secs later we start downloading the full chosen lang pack THEN -> gameloop()\n        let interval = setInterval(  () => {\n            if (!this.onSplash) {\n                clearInterval(interval);\n                this.dynamicallyLoadLanguageModule()\n            }\n        }, 2000);\n\n    }\n\n    \n    dynamicallyLoadLanguageModule() { \n        // this may be all wrong as it seems after the main package is loaded BOTH of these are prefetched... or is the conditional not for prefetch but for  real load?\n        if (this.gameMode === `english`) {\n            __webpack_require__.e(/*! import() | ./dictionaryEnglish */ \"./dictionaryEnglish\").then(__webpack_require__.bind(null, /*! ./dictionaryEnglish */ \"./src/dictionaryEnglish.js\")).then(({ englishDictionary }) => {\n                console.log(`ENG DICITONARY DLED`)\n\n                this.dictionary = englishDictionary\n                this.word = []\n                this.gameLoop();\n                return\n\n            }).catch((err) => {\n                alert(err)\n            })\n        } else if (this.gameMode === `chinese`) {\n            __webpack_require__.e(/*! import() | ./dictionaryChinese */ \"./dictionaryChinese\").then(__webpack_require__.bind(null, /*! ./dictionaryChinese */ \"./src/dictionaryChinese.js\")).then(({ chineseDictionary }) => {\n                console.log(`CN DICITONARY DLED`)\n\n                this.dictionary = chineseDictionary\n                this.word = []\n                this.gameLoop();\n                return\n\n            }).catch((err) => {\n                alert(err)\n            })\n        }\n    }\n\n\n    remakeGame (){\n        //basiclaly rerun constuctor here i did it in gameover()\n    }\n\n    get hasGameStarted(){\n        return !this.onSplash\n    }\n\n    get language(){\n        return this.gameMode\n    }\n\n    set setHP (desiredHP){\n        this.player.hp = desiredHP\n    }\n\n    ensureDefaultCTX () {\n        this.ctx.lineWidth = 1\n        this.ctx.shadowOffsetX = 0\n        this.ctx.shadowOffsetY = 0\n        this.ctx.strokeWeight = null\n    }\n\n\n    animateSplash(timeElapsed = 0){\n        console.log(`SPLASH ANIMATION`)\n        // ,timeElapsed)\n        // this.dynamicallyLoadLanguageModule()// SHOULD I PRE DOWNLOAD BASED OFF CURSOR CHOICE ON TTIMEELAPSED 0 && NOT DOWNLOADING?\n        // DOWNLOAD PROGRSS BAR \n    //     req.on( 'response', function ( data ) {\n    //     console.log(data.headers['content-length']);\n    // } );\n        \n        this.ensureDefaultCTX()\n\n        // background img\n        this.ctx.drawImage(this.splash, 0, 0, 1200, 900, 0, 0, this.canvas.width, this.canvas.height); //add credits of where i took image from\n\n        //title\n        this.ctx.font = `bold 100px ChronoType`;\n        this.ctx.fillStyle = \"black\";\n        this.ctx.strokeStyle = 'white';\n        this.ctx.strokeText('TYPING FANTASY!', this.canvas.width * .1-2, 100-3);\n        this.ctx.fillText('TYPING FANTASY!', this.canvas.width * .1, 100);\n\n        // language choices\n        this.ctx.font = `bold 50px ChronoType`;\n        this.ctx.fillStyle = \"black\";\n        this.ctx.strokeStyle = 'white';\n        this.ctx.strokeText('Choose a TYPING LANGUAGE and hit ENTER!', this.canvas.width * .05 - 2, (this.canvas.height * .5) - 3);\n        this.ctx.fillText('Choose a TYPING LANGUAGE and hit ENTER!', this.canvas.width * .05, (this.canvas.height * .5));\n        this.ctx.strokeText('ENGLISH 5-letter words', this.canvas.width * .1-2, (this.canvas.height * .6)-3);\n        this.ctx.fillText('ENGLISH 5-letter words', this.canvas.width * .1, (this.canvas.height * .6));\n        this.ctx.strokeText('CHINESE idioms', this.canvas.width * .1 -2, (this.canvas.height * .7)-3);\n        this.ctx.fillText('CHINESE idioms', this.canvas.width * .1, (this.canvas.height * .7));\n\n        // language selection logic\n        let up = this.keys[38];\n        let down = this.keys[40];\n        if (down && this.gameMode ===`english`) this.gameMode=`chinese`;\n        else if (up && this.gameMode===`chinese`) this.gameMode=`english`;\n        if (this.gameMode === `english`) this.ctx.drawImage(this.cursor, 0, 0, 32, 32, 25, 320, 50, 50 ); \n        else if (this.gameMode === `chinese`) this.ctx.drawImage(this.cursor, 0, 0, 32, 32, 25, 380, 50, 50);\n        \n        if (this.onSplash === true)\n        requestAnimationFrame( (rafTimeElapsed) => {\n             this.animateSplash(rafTimeElapsed);\n        })\n    }\n\n    _ensureDefaultSettings() {\n        this.isGameover = this.isGameover || false;\n        this.isPaused = this.isPaused || false;\n        this.gameMode = this.gameMode || `english`; \n        this.onSplash = this.onSplash || true;\n        this.lastTimeElapsed = this.lastTimeElapsed || 0;\n        this.rate = this.rate || 2000;\n    }\n\n    drawAttackArc(){  // this remains static after an attack until a new attack. could let chrono class take care of this.\n        // THIS IS WHERE THE ARC IS DRAWN)\n        if (this.player.circleCenterY) {\n            // first line of two\n            this.ctx.beginPath();\n            this.ctx.arc(this.player.circleCenterX, this.player.circleCenterY, this.player.diameter / 2, this.player.angleStartClockwise, this.player.angleEndClockwise, false)\n            this.ctx.strokeStyle = \"#FFFF00\";\n            this.ctx.lineWidth = 2;\n            this.ctx.lineCap = 'round'\n            this.ctx.stroke();\n            this.ctx.closePath();\n\n            // second line of two\n            this.ctx.beginPath();\n            this.ctx.arc(this.player.circleCenterX, this.player.circleCenterY, this.player.diameter / 2 + 10, this.player.angleStartClockwise, this.player.angleEndClockwise, false)\n            this.ctx.strokeStyle = \"#FFFF00\";\n            this.ctx.lineWidth = 1;\n            this.ctx.lineCap = 'round'\n            this.ctx.stroke();\n            this.ctx.closePath();\n        }\n    }\n\n    drawMap(){\n        // original image's 1024x768; we do a background render\n        this.ctx.drawImage(this.forestbg, 0, 0, 500, 350, 0, 0, this.canvas.width, this.canvas.height - 50);\n    }\n\n    drawEnemies(){\n        this.ensureDefaultCTX()\n\n        const possibilities = this.trie.possibilities(this.word.join(``));\n\n        // really shouldve used a enemies hash where enemies[`enemy.word`] = enemy object; a hash where the submitted word maps to the enemy object\n        for (let i = 0; i < this.enemies.length; i++) {\n            this.enemies[i].animate(this.player.x, this.player.y); // move towards player\n            if (possibilities.includes(this.enemies[i].word) && this.enemies[i].alive === true) this.enemies[i].animateReticle();\n        }\n\n    }\n\n    drawChineseEnemies() {\n        this.ensureDefaultCTX()\n\n        const possibilities = this.trie.possibilities(this.word);\n\n        // really shouldve used a enemies hash where enemies[`enemy.word`] = enemy object; a hash where the submitted word maps to the enemy object\n        for (let i = 0; i < this.enemies.length; i++) {\n            this.enemies[i].animate(this.player.x, this.player.y); // move towards player\n            if (possibilities.includes(this.enemies[i].word) && this.enemies[i].alive === true) this.enemies[i].animateReticle();\n        }\n\n    }\n    drawChineseTypingArea() {\n        this.ensureDefaultCTX()\n\n        this.fontSize = this.fontSize || 50;\n\n        //handles deleting old characters \n        this.ctx.clearRect(0, this.canvas.height - this.fontSize, this.canvas.width, this.fontSize);\n        //end deleting\n\n        //handles recoloring deleted user text area (maybe clearRect is redundant)\n        this.ctx.fillStyle = \"grey\";\n        this.ctx.fillRect(0, this.canvas.height - this.fontSize, this.canvas.width, this.fontSize);\n        //end recoloring\n\n        //user input word\n        this.ctx.fillStyle = \"blue\";\n        this.ctx.font = `bold ${this.fontSize}px ChronoType`;\n        // this.ctx.fillText(this.word.join(''), 0, (this.canvas.height));\n        //end user input word\n        // console.log(canvas.width/fontSize) = 25.6 atm but it can fit approx 44 charss-- all in arial 50s on a 1280 width\n\n\n\n    }\n\n\n    drawTypingArea() {\n        this.fontSize = this.fontSize || 50;\n\n        //handles deleting old characters \n        this.ctx.clearRect(0, this.canvas.height - this.fontSize, this.canvas.width, this.fontSize);\n        //end deleting\n\n        //handles recoloring deleted user text area (maybe clearRect is redundant)\n        this.ctx.fillStyle = \"grey\";\n        this.ctx.fillRect(0, this.canvas.height - this.fontSize, this.canvas.width, this.fontSize);\n        //end recoloring\n\n        //user input word\n        this.ctx.fillStyle = \"blue\";\n        this.ctx.font = `bold ${this.fontSize}px ChronoType`;\n        this.ctx.fillText(this.word.join(''), 0, (this.canvas.height));\n        //end user input word\n        // console.log(canvas.width/fontSize) = 25.6 atm but it can fit approx 44 charss-- all in arial 50s on a 1280 width\n\n    }\n \n    drawWPM() { \n        if (this.isPaused && !this.timeOfPauseStart) this.timeOfPauseStart = Date.now()\n        if (!this.isPaused && this.timeOfPauseStart) {\n            this.then = this.then + (Date.now() - this.timeOfPauseStart)\n            this.timeOfPauseStart = null\n        }\n        if (this.then === undefined) {\n            this.then = Date.now();\n        }\n\n        this.now = Date.now();\n        this.time = parseInt((this.now - this.then) / 1000);\n        this.wpm = parseInt(this.destroyedCount / (this.time / 60)) || 0; //0 to get rid of NaN\n        this.ctx.fillStyle = \"blue\";\n        this.ctx.font = `bold ${this.fontSize}px ChronoType`;\n        this.ctx.fillText('Time: ' + this.time + '  WPM: ' + this.wpm, this.canvas.width - 600, (this.canvas.height));\n    }\n\n    drawHeart() {\n        //THIS IS THE HEART ANIMATION FOR HP; add credits \n        this.ctx.beginPath();\n        this.ctx.strokeStyle = \"#000000\";\n        this.ctx.strokeWeight = 3;\n        this.ctx.shadowOffsetX = 4.0;\n        this.ctx.shadowOffsetY = 4.0;\n        this.ctx.lineWidth = 10.0;\n        this.ctx.fillStyle = \"#FF0000\";\n\n        let d = 30; // this is like the size\n        let k = 560; // this is where it is on diagonal\n        this.ctx.moveTo(k, k + d / 4);\n\n        this.ctx.quadraticCurveTo(k, k, k + d / 4, k);\n        this.ctx.quadraticCurveTo(k + d / 2, k, k + d / 2, k + d / 4);\n        this.ctx.quadraticCurveTo(k + d / 2, k, k + d * 3 / 4, k);\n        this.ctx.quadraticCurveTo(k + d, k, k + d, k + d / 4);\n        this.ctx.quadraticCurveTo(k + d, k + d / 2, k + d * 3 / 4, k + d * 3 / 4);\n        this.ctx.lineTo(k + d / 2, k + d);\n        this.ctx.lineTo(k + d / 4, k + d * 3 / 4);\n        this.ctx.quadraticCurveTo(k, k + d / 2, k, k + d / 4);\n        this.ctx.stroke();\n        this.ctx.fill();\n        this.ctx.closePath();\n        // end heart animation\n\n        // THIS IS THE HP NUMBER ANIMATION\n        this.ctx.fillStyle = \"blue\";\n        this.ctx.font = `bold ${this.fontSize}px ChronoType`;\n        this.ctx.fillText(`${this.player.hp}`, this.canvas.width - 195, (this.canvas.height));\n        \n    }\n\n    animate(timeElapsed = 0) {\n        // console.log(`ANIMATE`,timeElapsed)\n        if (this.isPaused || this.isGameover) return\n        //still unsure as to best way to do this\n        if (this.player.hp <= 0) {\n            this.isGameover = true\n            this.ctx.font = `bold 60px ChronoType`;\n            this.ctx.fillStyle = \"red\";\n            this.ctx.fillText('GAMEOVER', this.canvas.width * .4, this.canvas.height * .5);\n            this.gameover()\n            return\n        }\n\n        \n     \n\n        // console.log(time)\n        // animate this.player, this.enemies, and maybe track framecount\n        // whoever goes first is drawn on top of. so more important comes last\n        // furthermore, chrono should only give up 1 image of himself to animate not many CAN WE USE PASSING STRINGS THAT ARE EVALED HERE?\n        // OR DO WE JUST STRAIGHT UP CALL ANIMAATE IN THE CHRONO CLASS METHOD\n        if (timeElapsed - this.lastTimeElapsed > this.rate){\n            this.spawnEnemy();\n            this.lastTimeElapsed = timeElapsed;\n        }\n\n        this.drawMap(this.ctx, this.canvas);\n        this.drawAttackArc(this.ctx, this.player);\n\n        //to deal with all at once input in chinese vs piecemeal in english \n        switch (this.language) {\n            case (`chinese`): {\n                this.drawChineseEnemies(this.enemies, this.player);\n                this.drawChineseTypingArea(this.ctx, this.canvas, this.fontSize);\n                break\n            }\n            case (`english`): {\n                this.drawEnemies(this.enemies, this.player);\n                this.drawTypingArea(this.ctx, this.canvas, this.fontSize);\n                break\n            }\n        }\n       \n        this.drawWPM(this.ctx, this.canvas, this.fontSize);\n        this.drawHeart(this.ctx);\n\n        this.player.checkCollision()\n        this.player.animate();\n\n        if (this.isPaused) console.log(`pause hits animation`)\n        \n        if (!this.isPaused && !this.isGameOver)\n        this.request = requestAnimationFrame( (rafTimeElapsed) => {\n            {\n                this.animate(rafTimeElapsed);\n            }\n        }) //will not call the CB until the batch of animations inside current call stack frame animates at once. \n    }\n\n    // almost a misnomer at this point -- all game logic will be in animation from now on\n    gameLoop(){ //responsible for spawning initial actors, creating new actors, and calling animate-- will eventually stick all game logic in here including calls to \"move/act\" rather than letting animate take care of that implicitly\n        if (this.gameMode === `chinese`) {\n            this._detachListeners()\n            this._addListeners()       \n        }\n        // this.moveHighScoreTable();\n\n        this.trie = new _trie__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.enemies = [];\n        this.player = new _crono__WEBPACK_IMPORTED_MODULE_1__[\"default\"](300, 300, this.canvas, this.ctx, this.cronoleftimg, this.cronorightimg, this.cronoupimg, this.cronodownimg, this.cronothrust, this.keys, this.enemies);\n        _ui__WEBPACK_IMPORTED_MODULE_3__[\"default\"].addCheats()\n        this.animate();\n        return\n    }\n\n    spawnEnemy() {\n        let newEnemy = new _enemy__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Math.floor(Math.random() * this.canvas.width + 1),\n            Math.floor(Math.random() * this.canvas.height + 1), this.canvas, this.ctx, this.imp, 1, this.bluepaint, this.gameMode, this.squarereticle, this.dictionary)\n        this.enemies.push(newEnemy)\n        this.trie.addWord(newEnemy.word)\n        if (this.isGameover) return  //breaks spawning on gameover\n        // while (this.isPaused) {} //temporary solution; actually breaks the call stack\n        // if (this.isPaused) return\n\n        // setTimeout( ()=> this.spawnEnemy(this.rate), 1000 / this.rate)\n    }\n\n    _getResources(){\n        this.canvas = document.getElementById('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.cronoleftimg = document.getElementById('cronoleft');\n        this.cronorightimg = document.getElementById('cronoright');\n        this.cronodownimg = document.getElementById('cronodown');\n        this.cronoupimg = document.getElementById('cronoup');\n        this.forestbg = document.getElementById('forest');\n        this.imp = document.getElementById('imp');\n        this.cronothrust = document.getElementById('cronothrust');\n        this.bluepaint = document.getElementById('bluepaint');\n        this.splash = document.getElementById(`splash`);\n        this.cursor = document.getElementById(`cursor`)\n        this.squarereticle = document.getElementById(`squarereticle`);\n    }\n\n    _addListeners(){\n        this.keys = [] // used for moving\n        this.word = [] // what word you've typed \n\n        function preventDefaultViewportJiggling(e) {\n            const arrowsAndSpacebar = {\n                37: true,\n                38: true,\n                39: true,\n                40: true,\n                32: true,\n            }\n\n            Object.freeze(arrowsAndSpacebar)\n            if (arrowsAndSpacebar[e.keyCode]) e.preventDefault()\n        }\n\n        if (this.gameMode===`english`) {\n            this.keydownHandler = (e) => {\n                let key = e.keyCode\n                this.keys[key] = true;\n                \n            \n                preventDefaultViewportJiggling(e)\n\n\n                if (key >= 65 && key <= 90) this.word.push(String.fromCharCode(key).toLowerCase())\n                else if (key === 32 && !this.isGameover) {\n                    if (!this.isPaused) this.pause()\n                    else if (this.isPaused) this.unpause()\n                }\n                else if (key === 8) this.word.pop();\n                else if (key === 13) {\n                    if (this.onSplash) {\n                        this.onSplash = false\n                    } else {\n                        this.handleSubmit()\n                        this.word = [];\n                    }\n                }\n            }\n            // bad design i think i should have just made a chinese game or chinese fucns rather than if's in every key handling method\n        } else if (this.gameMode ===`chinese`) {\n                this.rate /= 1/4 // as the average idiom is like 4-8 cn chars and each char takes 2-4 leters for like 18 chars for one idiom submit\n                this.chineseInput = document.createElement(`input`)\n                this.chineseInput.setAttribute(`placeholder`,``)\n                this.chineseInput.style.height = \"0\"\n                this.chineseInput.style.width = \"0\"\n                this.chineseInput.style.margin = \"0\"\n                this.chineseInput.style.display = \"none\"\n\n                this.chineseAdvisoryText = document.createTextNode(\"Type chinese here\");\n                // this.linebreak = document.createElement(\"br\");\n                \n                this.chineseInput.style.position = `absolute`\n                document.body.insertBefore(this.chineseInput, document.body.children[document.body.children.length-1])\n                this.chineseInput.style.height = \"40px\"\n                this.chineseInput.style.width = \"180px\"\n                this.chineseInput.style.margin = \"2px\"\n\n                // this.canvas.insertAdjacentElement(`afterend`, this.chineseInput);\n                // this.chineseInput.insertAdjacentElement(`beforebegin`, this.linebreak);\n\n                //function here is hoisted to the top of _addListeners to a point before this.chineseinput was born\n                // hence ()=>{}ing it instead of doing function(){}\n                const attachChineseInputToCanvasBottomLeft = (yetToAttach = true) => {\n                    this.chineseInput.style.left = this.canvas.getBoundingClientRect().x + `px`\n                    this.chineseInput.style.top = this.canvas.getBoundingClientRect().bottom - (this.fontSize ? this.fontSize : 40) + `px`\n                    this.chineseInput.style.display = `block`\n                    if (yetToAttach) window.addEventListener('resize', \n                    this.chineseListener = () => attachChineseInputToCanvasBottomLeft(false)) ;\n                }\n                attachChineseInputToCanvasBottomLeft()\n                //to fix a glitch of it being slightly off-center;unsure of root cause\n                setTimeout(()=> attachChineseInputToCanvasBottomLeft(false), 100) \n\n                \n\n                this.keydownHandler = (e) => {\n                    let key = e.keyCode //should be nubmer\n                    this.keys[key] = true; //small range of keyboard keys means that this type of bucketing is acceptable\n                    // the larger the range of values in a set hte more costly it is to use bucket sort (just confused myself)\n                    // expense in meemory freom range and multiplying to get the right memory location from index ?\n\n                    //object freeze enum\n                    //prevent arrow keys from messsing with your viewport/scrolling \n\n                    preventDefaultViewportJiggling(e)\n                    this.chineseInput.focus()\n\n                    this.word = this.chineseInput.value\n                    // if (key >= 65 && key <= 90) this.word.push(String.fromCharCode(key).toLowerCase())\n                    // this.word = this.chineseInput.value\n                    if (key === 32 && !this.isGameover) {\n                        if (!this.isPaused) this.pause()\n                        else if (this.isPaused) this.unpause()\n                    }\n                    // else if (key === 8) this.word.pop();\n                    else if (key === 13) {\n                        if (this.onSplash) {\n                            this.onSplash = false\n                        } else {\n                            this.handleChineseSubmit()                            \n                        }\n                    }\n            }\n        }\n\n        this.keyupHandler = (e) => {\n            this.keys[e.keyCode] = false;\n        }\n\n      \n        document.body.addEventListener(\"keydown\",  this.keydownHandler, true);\n        document.body.addEventListener(\"keyup\",  this.keyupHandler, true);\n    }\n\n    handleChineseSubmit() {\n        this.word = this.chineseInput.value\n        if (this.player && this.word === `edward`) this.player.hp = Infinity\n        for (let i = 0; i < this.enemies.length; i++) {\n            if (this.enemies[i].word === this.word && this.enemies[i].alive === true) {\n                this.player.animateAttack(this.enemies[i].x, this.enemies[i].y - 50, this.cronothrust)\n                this.enemies[i].alive = false;\n                // socket.emit('word typed', this.word);\n\n                this.destroyedCount >= 1 ? this.destroyedCount++ : this.destroyedCount = 1\n            }\n        }\n        this.chineseInput.value = \"\"\n    }\n    \n\n    // chinese exception to remove the 1. the input box 2. the event listener on that box\n    _detachListeners(){\n        if (this.chineseInput) {\n            window.removeEventListener('resize', this.chineseListener); //REMOVE LISTENER BEFORE REMOVING THE HTTP ELEMENT\n            this.chineseInput.remove()\n        }\n\n\n\n        document.body.removeEventListener(\"keydown\", this.keydownHandler, true)\n        document.body.removeEventListener(\"keyup\", this.keyupHandler, true)\n        this.keys = []\n        this.word = []\n    }\n\n    //         console.log(time) went from time=10420 to 13420\n    // REMEMBER THAT OLD STUFF THAT WAS ON SCREEN REMAINS ON SCREEN EVEN AFTER ITS NO LONGER BEING CALLED\n    animateGameover(time, timeToPass = 3, previousElapsed) {\n        this.ctx.font = `bold 100px`\n        // console.log(time)\n        if (!this.initialAnimateGameoverTime) this.initialAnimateGameoverTime = time\n\n        const elapsed = timeToPass - ~~((time - this.initialAnimateGameoverTime)/1000)\n        // console.log(previousElapsed , elapsed )\n        this.ctx.fillText('GAMEOVER!', this.canvas.width * .4, this.canvas.height * .5);\n        if (previousElapsed !== elapsed) {\n            // if (elapsed === timeToPass)\n            // this.ctx.fillText(`Restart in ${elapsed}`, this.canvas.width * .4, this.canvas.height * .8 - this.fontSize * elapsed)\n            // else {\n            this.ctx.fillText(`${elapsed}`, this.canvas.width * .5, this.canvas.height * .9 - this.fontSize * elapsed)\n            // }\n        }\n        console.log((this.initialAnimateGameoverTime)) // the last time this fires is AFTEr the game has been delteed in settimeout\n        this.ctx.font = `bold 60px ChronoType`;\n        this.ctx.fillStyle = \"red\";\n        // const displayedFlooredTime = ~~(time - this.initialAnimateGameoverTime)\n        \n        \n        if (this.onGameover === true)\n        requestAnimationFrame( (timeElapsed) => {\n            this.animateGameover(timeElapsed, timeToPass, elapsed);\n        })\n        \n    }\n\n    async createHighscoreDialogBox() {\n        const username = prompt(`NEW HIGH SCORE! Please enter your moniker!\n                                You destroyed ${this.destroyedCount || 0} monsters!`, \"Name\");\n        const newScores = await fetch('./highscore', {\n                    method: 'POST',\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify([ this.destroyedCount || 0, username || `unnamed`])\n                }).then(res => {\n                    // console.log(`third`)\n                    return res.json()\n                })\n        _ui__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deleteScores()\n        _ui__WEBPACK_IMPORTED_MODULE_3__[\"default\"].createScoreTable(newScores)\n\n        // console.log(`fourth`)\n\n    }\n\n     async gameover() {\n        this.onGameover = true\n        this._detachListeners()\n\n        await fetch('./newhighscore', {\n            method: 'POST',\n            headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify([ this.destroyedCount || 0, 'irrelevant!' ])\n        }).then(response => response.json() ).then( warrantsNewHighScore => {\n            if (warrantsNewHighScore === true) {\n                this.createHighscoreDialogBox()\n                // console.log(` as soon as prompt finishes we are first`)\n            }\n        })     \n\n        //  console.log(`second`)\n\n        cancelAnimationFrame(this.request) //game animation is done for no matter what + returned \n\n        setTimeout( ()=> {\n            this.onGameover = false\n            // this.canvas.remove()\n            // let current = window.game\n            // current = {}\n            // console.log(window.game)\n            // console.log(this)\n            // console.log(`removed old canv`)\n            // document.body.insertBefore(this.canvas, document.querySelector(`#instructions`) )\n            // console.log(`inserted new canv`)\n            // delete this \n            _ui__WEBPACK_IMPORTED_MODULE_3__[\"default\"].destroyerOfObjects()\n            // console.log(`insetTIMEOUT`)\n            \n            window.game = new Game() // no more refs to old game so it hsould be garbage colelcted?\n            // its not ill figure htis out later its complicated\n\n        },3000)\n        \n        this.animateGameover()\n\n\n  \n    }\n//     pause hits pasue func\n//     game.js: 652 isPaused in pause() is set\n// game.js: 658 drawn pause text\n// game.js: 315 ANIMATE 35254.477\n// game.js: 362 pause hits animation\n    pause() {\n        // console.log(`pause hits pasue func`)\n        this.isPaused = true \n        // console.log(`isPaused in pause() is set`)\n\n        this.drawWPM() // to ensure we get that one snapshot of PAUSE TIME so that drawWPM isnt messed up by pause\n        this.ctx.font = `bold 50px ChronoType`;\n        this.ctx.fillStyle = \"red\";\n        this.ctx.fillText('PRESS SPACEBAR TO UNPAUSE', this.canvas.width * .2, this.canvas.height * .5);\n        // console.log(`drawn pause text`)\n    }\n\n    unpause() {\n        this.isPaused = false\n        this.animate()\n    }\n    \n    handleSubmit() {\n        if (this.player && this.word.join(``) === `edward`) this.player.hp = Infinity\n        for (let i = 0; i < this.enemies.length; i++) {\n            if (this.enemies[i].word === this.word.join(``) && this.enemies[i].alive === true) {\n                this.player.animateAttack(this.enemies[i].x, this.enemies[i].y - 50, this.cronothrust)\n                \n                // const event = new EventEmitter();\n                //console.log(socket)\n                // console.log(socket)\n                // socket.emit('word typed', this.word.join(``));\n\n                this.enemies[i].alive = false;\n                this.destroyedCount >= 1 ? this.destroyedCount++ : this.destroyedCount = 1\n            }\n        }\n    }\n\n  \n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui */ \"./src/ui.js\");\n\n\n// asap:1. walking animaton based on EITHER instance variable keeping track of past actions\n// OR just count requestanimationframe frames IDK\n// 2. collisions and damage on chrono\n// 3. bloody pool for death animation for both crono and monsters\n// 4. functions with instance variables to track last lifetime of animation like the jumping tracers? or just a settimeout\n\n// FUTURE:\n// 1. show WPM somewhere need to keep track of time elapsed DONE\n// 2. gameover reset the game \n// 3. animate attack from crono-- should he just teleport everywhere and use x-attack? OR HUGE ARC with MATH that he flies through SOMEWHAT SOLVED\n// 4. how does crono lose? do monsters need to attack him he needs hp or soemthing or if more than 5monsters are alive at once he loses\n// 5. make it feel more alive with actual edges that crono and monsters cant spawn/cross\n// 6. monsters move randomly left and right to and fro, also spawn preferentially away from existing monsters??\n// 7. animate random movement, walking, and standing so it doesnt look like crono is skating\n// 8. options/welcome screen/ choosing difficulty such as spawn rate\n// 9. animate monster death\n// 10. glitch: moving down+left double animates  SOLVED\n// 11. maybe huge melee limit break swing but will take a lot of either async/instance variables tracking/animationframes counting\n\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    \n    // UI.__proto__ is native code\n    // UI.prototype.constructor === UI === {staticmethod: func(){}, prototype: {instance methods here} } \n    // UI.prototype = {constructor: UI, normalmethod: func(){} }\n    // cannot assign to this\n    // THe problem: A static method calls this.instanceMethod(). The this is UI.prototype.constructor NOT UI.prototype\n    // Fix: if (!this.hasOwnproperty(`constructor`)) \\\n\n    // classes always have a syntactic box around them i guess and are run in strict mode so they dont have access to qs\n    // GENERAL RULE IS THE CALLER OF A FUNCTION IS THE THIS INSIDE THE FUNCTION\n    // CALLING A METHOD WITHOUT AN OBJECT: Class.prototype.normalMethod \n    // (THIS in normalMethod is going to be Class.prototype, the caller, normally it would the object)\n    // CALLING A STATIC METHOD WITH AN OBJECT: obj.__proto__.constructor.staticMETHOD\n    // Class.prototype.constructor.static methods here\n    // UI.prototype.constructor ==  UI\n    // window.UI = UI\n    _ui__WEBPACK_IMPORTED_MODULE_1__[\"default\"].styleTooltip() //onetime\n    _ui__WEBPACK_IMPORTED_MODULE_1__[\"default\"].handleClipboard() //onetime\n    _ui__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fetchScores()\n\n    window.game = new _game__WEBPACK_IMPORTED_MODULE_0__[\"default\"]() // window for testing\n \n\n    \n   \n\n    // Notification.requestPermission()\n    // setTimeout( () => { \n    //     if (Notification.permission === \"granted\") new Notification(\"You've played for 5 minutes!\")\n    // }, 300000)\n\n})\n\n\n\n// from https://orteil.dashnet.org/cookieclicker/\n// var PlaySound = function (url, vol, pitchVar) {\n//     //url : the url of the sound to play (will be cached so it only loads once)\n//     //vol : volume between 0 and 1 (multiplied by game volume setting); defaults to 1 (full volume)\n//     //(DISABLED) pitchVar : pitch variance in browsers that support it (Firefox only at the moment); defaults to 0.05 (which means pitch can be up to -5% or +5% anytime the sound plays)\n//     var volume = 1;\n//     var pitchVar = (typeof pitchVar === 'undefined') ? 0.05 : pitchVar;\n//     var rate = 1 + (Math.random() * 2 - 1) * pitchVar;\n//     if (typeof vol !== 'undefined') volume = vol;\n//     if (!Game.volume || volume == 0) return 0;\n//     if (!Sounds[url]) {\n//         //sound isn't loaded, cache it\n//         Sounds[url] = new Audio(url);\n//         Sounds[url].onloadeddata = function (e) { PlaySound(url, vol, pitchVar); }\n//     }\n//     else if (Sounds[url].readyState >= 2) {\n//         var sound = SoundInsts[SoundI];\n//         SoundI++;\n//         if (SoundI >= 12) SoundI = 0;\n//         sound.src = Sounds[url].src;\n//         //sound.currentTime=0;\n//         sound.volume = Math.pow(volume * Game.volume / 100, 2);\n//         if (pitchSupport && rate != 0) {\n//             sound.preservesPitch = false;\n//             sound.mozPreservesPitch = false;\n//             sound.webkitPreservesPitch = false;\n//             sound.playbackRate = rate;\n//         }\n//         sound.play();\n//     }\n// }\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/trie.js":
/*!*********************!*\
  !*** ./src/trie.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Trie; });\nclass Trie {\n    constructor() {\n        this.trie = {}\n    }\n\n    addWord (string) {\n        let current = this.trie\n        for (const char of string) {\n            if (!current.hasOwnProperty(char)) {\n                current[char] = {}\n            }\n            current = current[char]\n        }\n        current[`finished`] = string\n    }\n\n    removeWord (string) {\n    }\n\n    possibilities (substring) {\n        const possibilities = []\n        if (substring.length === 0) return possibilities //wait until at least 1 letter is typed otherwise possibilities are EVERY word\n        let current = this.trie\n        for (const char of substring) {\n            if (!current.hasOwnProperty(char)) return possibilities \n            current = current[char]\n        }        \n        dfs(current)\n        function dfs (current) {\n            for (const key in current) {\n                if (key === `finished`) possibilities.push(current[key])\n                else dfs(current[key])\n            }\n        }\n        return possibilities\n    }\n}\n\n\n//# sourceURL=webpack:///./src/trie.js?");

/***/ }),

/***/ "./src/ui.js":
/*!*******************!*\
  !*** ./src/ui.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return UI; });\n// THIS IS FOR NAMESPACING. UI HAS NO like \"state\" to track of. So constructor is unused\n\nclass UI {\n  \n\n    static styleTooltip (){\n        const tooltipStyle = {\n            position: `relative`,\n            display: `inline-block`,\n        }\n\n        const tooltiptextStyle = {\n            ...tooltipStyle,\n            // visibility: `hidden`,\n            display: `none`,\n            // width: `150px`,\n            backgroundColor: `black`,\n            color: `#fff`,\n            textAlign: `left`,\n            borderRadius: `6px`,\n            padding: `5px 0`,\n            /* Position the tooltip */\n            position: `absolute`,\n            zIndex: `1`,\n        }\n\n        Object.assign(document.querySelector(`#cheat-tooltiptext`).style, tooltiptextStyle)\n        Object.assign(document.querySelector(`#cheat-tooltip`).style, tooltipStyle)\n    }\n\n    static handleClipboard () {\n        //one-time CLIPBOARD COPY MY EMAIL HANDLING\n        function fallbackCopyTextToClipboard(text) {\n            var textArea = document.createElement(\"textarea\");\n            textArea.value = text;\n\n            // Avoid scrolling to bottom\n            textArea.style.top = \"0\";\n            textArea.style.left = \"0\";\n            textArea.style.position = \"fixed\";\n\n            document.body.appendChild(textArea);\n            textArea.focus();\n            textArea.select();\n\n            try {\n                var successful = document.execCommand('copy');\n                var msg = successful ? 'successful' : 'unsuccessful';\n                console.log('Fallback: Copying text command was ' + msg);\n            } catch (err) {\n                console.error('Fallback: Oops, unable to copy', err);\n            }\n\n            document.body.removeChild(textArea);\n        }\n\n        function copyTextToClipboard(text) {\n            if (!navigator.clipboard) {\n                fallbackCopyTextToClipboard(text);\n                return;\n            }\n\n            navigator.clipboard.writeText(text).then(() => {\n                console.log('Async: Copying to clipboard was successful!');\n            }, (err) => {\n                console.error('Async: Could not copy text: ', err);\n            });\n        }\n\n        const clipboardImage = document.querySelector(`#clipboard`)\n        clipboardImage.addEventListener('click', function () {\n            copyTextToClipboard('edward@utexas.edu');\n            this.style.height = `30px`\n            setTimeout(function () {\n                this.style.height = `25px`\n            }.bind(this), 500)\n        });\n    }\n\n  \n    static ensureSorted (scores)  {\n        const sorted = scores.sort((a, b) => b[0] - a[0])\n\n        return ({\n            sorted,\n            'noInconsistency': (JSON.stringify(sorted) === JSON.stringify(scores))\n        })\n    }\n\n    static async fetchScores() {\n        let data\n        const defaultData = Object.freeze([[123, \"Edward\"], [50, \"John\"], [30, \"Crono\"], [25, \"Scala\"], [15, \"Robo\"]])\n        try {\n            // fetch(./highscore) in index.html\n            data = await fetch(`highscore`).then(res => res.json()) // res is a response object and running res.json() returns a promsie on the body stream is async so cant access res\n        } catch (err) {\n            console.log(err)\n            data = defaultData\n        } finally {\n            UI.createScoreTable(data)\n        }\n    };\n\n    static createScoreTable (scores) {\n        const { noInconsistency: noInconsistency, sorted } = this.ensureSorted(scores)\n        if (!noInconsistency) throw `high scores' broken`\n        const textNode = document.createTextNode.bind(document)\n        const lineBreak = () => document.createElement(`br`)\n        const table = document.querySelector(`#highscore`)\n\n        for (let [index, [score, name]] of Object.entries(scores)) {\n            table.appendChild(\n                textNode(`${++index}. ${name} scored ${score}`)\n            )\n            table.appendChild(lineBreak())\n        }\n        table.style.position = `absolute`\n        UI.attachTableToCanvasRight(table)\n    };\n\n    static attachTableToCanvasRight (table, yetToAttach = true)  {\n        const canvas = document.getElementById(`canvas`)\n        table.style.left = 10 + canvas.getBoundingClientRect().right + `px`\n        table.style.top = canvas.getBoundingClientRect().y + `px`\n        if (yetToAttach) window.addEventListener('resize', () => this.attachTableToCanvasRight(table, false));\n    }\n\n    static deleteScores() {\n        console.log(`delete`,this)\n        const table = document.querySelector(`#highscore`)\n        table.innerHTML = table.innerHTML.split(`</h1>`)[0]\n    }\n\n    static destroyerOfObjects() {\n        for (let prop in window.game) {\n            eval(`delete window.game.${prop} `)\n        }\n    }\n\n\n\n    static addCheats() {\n        const qs = document.querySelector.bind(globalThis.document)\n\n        const linkedin = qs(\"a[href='https://www.linkedin.com/in/edzhou/']\");\n        const github = qs(\"a[href='https://github.com/featurerich1/']\");\n        const email = qs(\"a[href^='mailto']\");\n\n\n        linkedin.addEventListener(`click`, () => {\n            if (!window.game.onSplash) window.game.rate = 2 * window.game.rate\n\n        }, false)\n\n        email.addEventListener(`mouseenter`, () => {\n            if (!window.game.onSplash) window.game.rate = .66 * window.game.rate\n        }, false)\n    }\n\n}\n\n//# sourceURL=webpack:///./src/ui.js?");

/***/ })

/******/ });